'use strict';

module.exports = ErrorEx;

function ErrorEx(message, properties) {
	if (!(this instanceof ErrorEx)) {
		return new ErrorEx(message, properties);
	}

	Error.call(this);

	if (message) {
		this.message = message;
	}

	Object.defineProperty(this, 'name', {
		enumerable: false,
		configurable: true,
		value: this.constructor.name,
		writable: true
	});

	if (Error.captureStackTrace) {
		Error.captureStackTrace(this, this.constructor);
	}

	if (properties) {
		for (var key in properties) {
			this[key] = properties[key];
		}
	}
}

ErrorEx.prototype = Object.create(Error.prototype, {
	constructor: {
		value: ErrorEx,
		enumerable: false,
		writable: true,
		configurable: true
	}
});

ErrorEx.appendStack = function appendStack(sourceStack, destStack) {
	if (sourceStack) {
		return destStack + '\n' + sourceStack;
	}
	return destStack;
};

ErrorEx.subclass = function subclass(name, properties) {
	if (typeof name === 'object') {
		properties = name;
		name = null;
	}

	var SubErrorEx = function ErrorExSubclass(message, props) {
		if (!(this instanceof SubErrorEx)) {
			return new SubErrorEx(message, props);
		}

		ErrorEx.call(this, message, props);

		if (properties) {
			for (var key in properties) {
				if (properties.hasOwnProperty(key)) {
					this[key] = properties[key];
				}
			}
		}
	};

	SubErrorEx.prototype = Object.create(ErrorEx.prototype, {
		constructor: {
			value: SubErrorEx,
			enumerable: false,
			writable: true,
			configurable: true
		}
	});

	if (name) {
		Object.defineProperty(SubErrorEx.prototype, 'name', {
			enumerable: false,
			configurable: true,
			value: name,
			writable: true
		});
	}

	SubErrorEx.subclass = ErrorEx.subclass;
	SubErrorEx.appendStack = ErrorEx.appendStack;

	return SubErrorEx;
};

